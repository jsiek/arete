// permissions
const none = 0;
const half = 1/2;
const all = 1;

const data = 0;
const pred = 1;
const succ = 2;

const head = 0;
const tail = 1;

fun listof(let dat) {
  var p = &⟨dat, null, null⟩;
  return split(p);
}

fun push(let dat, var lst) {
  var first = &⟨dat, null, null⟩;
  if (lst[head] == lst[tail]) { // lst is a 1 element list
    var n = copy(join(lst[0], lst[1]));
    (*n)[pred] = none of first;
    (*first)[succ] = half of n;
    (*n)[1] <- half of first;
    lst[head] = first;
    lst[tail] = n;
    return lst;
  } else { // lst has at least 2 elements
    lst[head] <- all of (*((*(lst[0]))[2]))[1];
    (*lst[head])[1] = none of first;
    (*((*(lst[0]))[2]))[1] <- half of lst[0];
    (*first)[succ] = lst[head];
    (*((*first)[2]))[1] <- half of first;
    lst[head] = first;
    return lst;
  }
}

fun delete_nodes(var node, last) {
  if (not is_null(node)) {
    if (node == last) {
      delete join(node, last);
    } else {
      node <- all of (*((*node)[2]))[1];
      ! delete_nodes(copy((*node)[succ]), all of last);
      delete node;
    }
  }
}

fun delete_list(var list) {
  ! delete_nodes(copy(list[head]), copy(list[tail]));
}

fun main() {
  var three = listof(3);
  var two_three = push(2, three);
  var one_two_three = push(1, two_three);
  let one = copy(one_two_three[head][data]);
  ! delete_list(one_two_three);
  return one - 1;
}
