// permissions
const none = 0;
const half = 1/2;
const all = 1;

const data = 0;
const prev = 1;
const next = 2;

const head = 0;
const tail = 1;

fun listof(let dat) {
  var p = &⟨dat, null, null⟩;
  return split(p);
}

fun push(let dat, var lst) {
  var first = &⟨dat, null, null⟩;
  if (lst[head] == lst[tail]) { // lst is a 1 element list
    var n = copy(join(lst[head], lst[tail]));
    (*n)[prev] = none of first;
    (*first)[next] = half of n;
    (*n)[1] <- half of first;
    lst[head] = first;
    lst[tail] = n;
    return lst;
  } else { // lst has at least 2 elements
    lst[head] <- all of (* (* lst[head])[next])[prev];
    (*lst[head])[prev] = none of first;
    (* (* lst[head])[next])[prev] <- half of lst[head];
    (*first)[next] = lst[head];
    (* (*first)[next])[prev] <- half of first;
    lst[head] = first;
    return lst;
  }
}


fun delete_list(var lst) {
  if (lst[head] == lst[tail]) { // lst is a 1 element list
    var n = copy(join(lst[head], lst[tail]));
    delete n;
  } else {
    lst[head] <- all of (*(*lst[head])[next])[prev];
    // The `ref` variable is to allow for variables that have less
    // than 1 permission (like `let`) but that do not guarantee
    // immutability. Like `var` they take all the permission from
    // their initializer, but they do not consume the initializer.
    ref nxt = copy((*lst[head])[next]);
    delete lst[head];
    lst[head] = nxt;
    ! delete_list(lst);
  }
}

fun main() {
  var three = listof(3);
  var two_three = push(2, three);
  var one_two_three = push(1, two_three);
  let one = copy((*one_two_three[head])[data]);
  ! delete_list(one_two_three);
  return one - 1;
}
