// AVL Tree (UNDER CONSTRUCTION)
// tree layout: pointer to root
const root = 0;
// node layout: pointer to ⟨data, left, right, parent, height⟩
const data = 0;
const left = 1;
const right = 2;
const parent = 3;
const height = 4;

type node_t = rec X in ⟨int, X, X, X, int⟩*;
type tree_t = node_t*;

// Common fractions
const none = 0/1;
const half = 1/2;
const all = 1/1;

fun find(let key: int, ref node: node_t, ref p: node_t) -> node_t {
  if (is_null(node)) {
    return p;
  }
  if (key < (*node)[data]) {
    return find(key, copy((*node)[left]), node);
  }
  if ((*node)[data] < key) {
    return find(key, copy((*node)[right]), node);
  }
  return node;
}

fun gather_permission(inout node: node_t) {
  if (not is_null((*node)[left])) {
    node <- all of (*((*node)[left]))[parent];
  }
  if (not is_null((*node)[right])) {
    node <- all of (*((*node)[right]))[parent];
  }
  assert permission(node) == 1/1;
}

fun scatter_permission(inout node: node_t) {
  if (not is_null((*node)[left])) {
    (*((*node)[left]))[parent] <- half of node;
  }
  if (not is_null((*node)[right])) {
    (*((*node)[right]))[parent] <- half of node;
  }
}

fun set_left(inout node: node_t, var new_left: node_t) {
  if (not is_null(new_left)) {
    (*new_left)[parent] = none of node;
  }
  (*node)[left] = 1/2 of new_left;
  (*new_left)[parent] <- 1/2 of node;
  (*node)[left] <- all of new_left;  
}

fun set_right(inout node: node_t, var new_right: node_t) {
  if (not is_null(new_right)) {
    (*new_right)[parent] = none of node;
  }
  (*node)[right] = 1/2 of new_right;
  (*new_right)[parent] <- 1/2 of node;
  (*node)[right] <- all of new_right;
}

fun insert(let key: int, inout tree: tree_t) {
  if (is_null(*tree)) {
    *tree = &⟨key, null, null, null, 0⟩;
  } else {
    var node: node_t = find(key, *tree, null);
    if (key < (*node)[data]) {
      var new_node = &⟨key, null, null, null, 0⟩;
      ! gather_permission(node);
      ! set_left(node, new_node);
      ! scatter_permission(node);
    }
    if ((*node)[data] < key) {
      var new_node = &⟨key, null, null, null, 0⟩;
      ! gather_permission(node);
      ! set_right(node, new_node);
      ! scatter_permission(node);
    }
  }
}

fun delete_node(var node: node_t) {
  if (not is_null(node)) {
    ! gather_permission(node);
    ! delete_node((*node)[left]);
    ! delete_node((*node)[right]);
    delete node;
  }
}

fun delete_tree(var tree: tree_t) {
  ! delete_node(copy(*tree));
  delete tree;
}

fun main() {
  var tree : tree_t = &null;
  ! insert(5, tree);
  ! insert(10, tree);
  ! insert(1, tree);
  let ten = (let n: node_t = find(10, *tree, null)
             in copy((*n)[data]));
  ! delete_tree(tree);
  return ten - 10;
}
