// permissions
const none : rational = 0/1;
const half : rational = 1/2;
const all : rational = 1/1;

const data : int = 0;
const prev : int = 1;
const next : int = 2;

const head : int = 0;
const tail : int = 1;

type node_t = rec X in ⟨int, X, X⟩*;
type list_t = ⟨node_t, node_t⟩;

fun listof(let dat: int) -> ⟨node_t, node_t⟩ {
  var p = &⟨dat, null, null⟩;
  return split(p);
}

fun push(let dat: int, var lst: list_t) -> list_t {
  var first = &⟨dat, null, null⟩;
  if (lst[head] == lst[tail]) { // lst is a 1 element list
    var n = copy(join(lst[head], lst[tail]));
    (*n)[prev] = none of first;
    (*first)[next] = half of n;
    (*n)[1] <- half of first;
    lst[head] = first;
    lst[tail] = n;
    return lst;
  } else { // lst has at least 2 elements
    lst[head] <- all of (* (* lst[head])[next])[prev];
    (*lst[head])[prev] = none of first;
    (* (* lst[head])[next])[prev] <- half of lst[head];
    (*first)[next] = lst[head];
    (* (*first)[next])[prev] <- half of first;
    lst[head] = first;
    return lst;
  }
}

fun delete_list(var lst: list_t) {
  if (lst[head] == lst[tail]) { // lst is a 1 element list
    var n : node_t = copy(join(lst[head], lst[tail]));
    delete n;
  } else {
    lst[head] <- all of (*(*lst[head])[next])[prev];
    ref nxt : node_t = copy((*lst[head])[next]);
    delete lst[head];
    lst[head] = nxt;
    ! delete_list(lst);
  }
}

fun main() {
  var three : list_t = listof(3);
  var two_three : list_t = push(2, three);
  var one_two_three : list_t = push(1, two_three);
  let one : int = copy((*one_two_three[head])[data]);
  ! delete_list(one_two_three);
  return one - 1;
}
