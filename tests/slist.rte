var null = fn { return (new ⟨⟩) ! write; };
var push = fn data, write list {
  return (new ⟨ data, write (list ! none) ⟩) ! write;
};
var head = fn list {
  match *list
  | case ⟨hd, tl⟩:
    return hd;
};
var tail = fn list {
  match *list
  | case ⟨hd, tl⟩:
    tl ! read;
    return tl;     // return creates a copy, but that aliases with the cdr
};
var is_null = fn ptr {
  match *ptr
  | case ⟨⟩:
    return true;
  | case ⟨_, _⟩:
    return false;
};
var is_last = fn n {
  match *n
  | case ⟨⟩:
    return false;
  | case ⟨_, next⟩: {
    next ! read;
    var ans = is_null(next);
    next ! write;
    return ans;
  }
};

var remove_last = fn write n {
  n ! read;
  if is_null(n) then
    return 0;
  else if is_last(tail(n)) then {
    match *n
    | case ⟨data, p⟩:
      var q = (p ! none);
      n ! write;
      n := ⟨data, write null()⟩;
      return q;
  } else {
    match *n
    | case ⟨data, write p⟩:
      return remove_last(p);
  }
};
var delete_list = fn write n {
  {
    match *n
    | case ⟨⟩:
    | case ⟨data, p⟩:
      delete_list(p ! none);
  }
  delete n;
};
var one_two = write push(1, push(2, null()));
var two_null = remove_last(one_two ! none);
var one = head(one_two);
var two = head(two_null);
delete_list(one_two);
two_null ! none;
delete_list(two_null);
return one + 1 - two;
