var null = fn -> write { return new ⟨⟩; };
var push = fn data, write list -> write {
  return new ⟨ data, write list ⟩;
};
var head = fn list {
  return (*list)[0];
};
var tail = fn list {
  return (*list)[1];
};
// mutable access to the tail
var mtail = fn list -> write {
  return (*list)[1];
};
var is_null = fn ptr {
  match *ptr
  | case ⟨⟩:
    return true;
  | case ⟨_, _⟩:
    return false;
};
var is_last = fn n {
  if is_null(n) then
    return false;
  else {
    return is_null(tail(n));
  }
};
// Split the list into two parts, with the second
// part just containing the last element.
var remove_last = fn write n -> write {
  if is_null(n) then
    return 0;
  else if is_last(tail(n)) then {
      var q = write mtail(n);
      n := ⟨head(n), write null()⟩;
      return q;
  } else {
    return remove_last(mtail(n));
  }
};
var delete_list = fn write n {
  if is_null(n) then
    delete n;
  else {
    delete_list(mtail(n));
    delete n;
  }
};
var one_two = write push(1, push(2, null()));
var two_null = write remove_last(one_two);
var one = head(one_two);
var two = head(two_null);
delete_list(one_two);
delete_list(two_null);
return one + one - two;
