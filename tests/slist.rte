type opt_ptr = variant ptr: ?* | null: ⟨⟩;

fun null() -> opt_ptr { return tag null(⟨⟩) as opt_ptr; }
fun is_null(let p : opt_ptr) {
  match (p) {
    case null(t):
      return true;
    case ptr(q):
      return false;
  }
}
fun ptr(var p : ?*) -> opt_ptr { return tag ptr(p) as opt_ptr; }

fun listof(let data) {
  return ptr(&⟨data, null()⟩);
}

fun push(let data, var list) {
  return ptr(&⟨data, list⟩);
}

fun data(let node) & {
  match (node) {
  case null(w):
    return 0; // raise an exception
  case ptr(n):
    return (*n)[0];
  }
}

fun next(let node) & {
  return (*node)[1];
}

fun is_last(let node) {
  match (node) {
  case null(w):
    return false;
  case ptr(n):
    return is_null(next(n));
  }
}

// Split the list into two parts, with the second
// part just containing the last element.
fun remove_last(inout n) {
  match (n) {
  case null(q):
    return null();
  case ptr(var node):
    if (is_last(next(node))) {
      var q = copy((*node)[1]); // want all permissions to next(n)
      (*node)[1] = null();
      return q;
    } else {
      return remove_last((*n)[1]);
    }
  }
}

fun main() {
  var one_two = push(1, listof(2));
  var two_null = remove_last(one_two);
  let one = data(one_two);
  let two = data(two_null);
  return one + one - two;
}
