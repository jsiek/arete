type opt_ptr = variant ptr: ?* | null: ⟨⟩;

fun null() -> opt_ptr { return tag null(⟨⟩) as opt_ptr; }
fun is_null(let p : opt_ptr) {
  match (p) {
    case null(t):
      return true;
    case ptr(q):
      return false;
  }
}
fun ptr(var p : ?*) -> opt_ptr { return tag ptr(p) as opt_ptr; }

type list_t = rec X in (variant ptr: ⟨int, X⟩* | null:⟨⟩);

fun listof(let data: int) -> list_t {
  return ptr(&⟨data, null()⟩);
}

fun push(let data: int, var lst: list_t) -> list_t {
  return ptr(&⟨data, lst⟩);
}

fun data(let node: list_t) -> int & {
  match (node) {
  case null(w):
    return 0; // raise an exception
  case ptr(n):
    return (*n)[0];
  }
}

fun next(let node: ⟨int, list_t⟩*) -> list_t & {
  return (*node)[1];
}

fun is_last(let node: list_t) -> bool {
  match (node) {
  case null(w):
    return false;
  case ptr(n):
    return is_null(next(n));
  }
}

// Split the list into two parts, with the second
// part just containing the last element.
fun remove_last(inout n : list_t) -> list_t {
  match (n) {
  case null(q):
    return null;
  case ptr(inout node: ⟨int, list_t⟩*):
    if (is_last(next(node))) {
      var q = copy((*node)[1]); // want all permissions to next(n)
      (*node)[1] = null();
      return q;
    } else {
      return remove_last((*node)[1]);
    }
  }
}

fun main() {
  var one_two = push(1, listof(2));
  var two_null = remove_last(one_two);
  let one = data(one_two);
  let two = data(two_null);
  return one + one - two;
}
